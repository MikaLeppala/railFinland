import {
  __commonJS
} from "./chunk-G3PMV62Z.js";

// node_modules/osmtogeojson/lodash.custom.js
var require_lodash_custom = __commonJS({
  "node_modules/osmtogeojson/lodash.custom.js"(exports, module) {
    (function() {
      var arrayPool = [];
      var indicatorObject = {};
      var maxPoolSize = 40;
      var reFlags = /\w*$/;
      var reFuncName = /^\s*function[ \n\r\t]+\w/;
      var reThis = /\bthis\b/;
      var shadowedProps = [
        "constructor",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "toLocaleString",
        "toString",
        "valueOf"
      ];
      var argsClass = "[object Arguments]", arrayClass = "[object Array]", boolClass = "[object Boolean]", dateClass = "[object Date]", errorClass = "[object Error]", funcClass = "[object Function]", numberClass = "[object Number]", objectClass = "[object Object]", regexpClass = "[object RegExp]", stringClass = "[object String]";
      var cloneableClasses = {};
      cloneableClasses[funcClass] = false;
      cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
      var descriptor = {
        "configurable": false,
        "enumerable": false,
        "value": null,
        "writable": false
      };
      var iteratorData = {
        "args": "",
        "array": null,
        "bottom": "",
        "firstArg": "",
        "init": "",
        "keys": null,
        "loop": "",
        "shadowedProps": null,
        "support": null,
        "top": "",
        "useHas": false
      };
      var objectTypes = {
        "boolean": false,
        "function": true,
        "object": true,
        "number": false,
        "string": false,
        "undefined": false
      };
      var root = objectTypes[typeof window] && window || this;
      var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
      var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
      var freeGlobal = objectTypes[typeof global] && global;
      if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
        root = freeGlobal;
      }
      function getArray() {
        return arrayPool.pop() || [];
      }
      function isNode(value) {
        return typeof value.toString != "function" && typeof (value + "") == "string";
      }
      function releaseArray(array) {
        array.length = 0;
        if (arrayPool.length < maxPoolSize) {
          arrayPool.push(array);
        }
      }
      function slice(array, start, end) {
        start || (start = 0);
        if (typeof end == "undefined") {
          end = array ? array.length : 0;
        }
        var index = -1, length = end - start || 0, result = Array(length < 0 ? 0 : length);
        while (++index < length) {
          result[index] = array[start + index];
        }
        return result;
      }
      var arrayRef = [];
      var errorProto = Error.prototype, objectProto = Object.prototype, stringProto = String.prototype;
      var toString = objectProto.toString;
      var reNative = RegExp(
        "^" + String(toString).replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/toString| for [^\]]+/g, ".*?") + "$"
      );
      var fnToString = Function.prototype.toString, getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, hasOwnProperty = objectProto.hasOwnProperty, push = arrayRef.push, propertyIsEnumerable = objectProto.propertyIsEnumerable, unshift = arrayRef.unshift;
      var defineProperty = function() {
        try {
          var o = {}, func = isNative(func = Object.defineProperty) && func, result = func(o, o, o) && func;
        } catch (e) {
        }
        return result;
      }();
      var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate, nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray, nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys;
      var ctorByClass = {};
      ctorByClass[arrayClass] = Array;
      ctorByClass[boolClass] = Boolean;
      ctorByClass[dateClass] = Date;
      ctorByClass[funcClass] = Function;
      ctorByClass[objectClass] = Object;
      ctorByClass[numberClass] = Number;
      ctorByClass[regexpClass] = RegExp;
      ctorByClass[stringClass] = String;
      var nonEnumProps = {};
      nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = { "constructor": true, "toLocaleString": true, "toString": true, "valueOf": true };
      nonEnumProps[boolClass] = nonEnumProps[stringClass] = { "constructor": true, "toString": true, "valueOf": true };
      nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = { "constructor": true, "toString": true };
      nonEnumProps[objectClass] = { "constructor": true };
      (function() {
        var length = shadowedProps.length;
        while (length--) {
          var key = shadowedProps[length];
          for (var className in nonEnumProps) {
            if (hasOwnProperty.call(nonEnumProps, className) && !hasOwnProperty.call(nonEnumProps[className], key)) {
              nonEnumProps[className][key] = false;
            }
          }
        }
      })();
      function lodash() {
      }
      var support = lodash.support = {};
      (function() {
        var ctor = function() {
          this.x = 1;
        }, object = { "0": 1, "length": 1 }, props = [];
        ctor.prototype = { "valueOf": 1, "y": 1 };
        for (var key in new ctor()) {
          props.push(key);
        }
        for (key in arguments) {
        }
        support.argsClass = toString.call(arguments) == argsClass;
        support.argsObject = arguments.constructor == Object && !(arguments instanceof Array);
        support.enumErrorProps = propertyIsEnumerable.call(errorProto, "message") || propertyIsEnumerable.call(errorProto, "name");
        support.enumPrototypes = propertyIsEnumerable.call(ctor, "prototype");
        support.funcDecomp = !isNative(root.WinRTError) && reThis.test(function() {
          return this;
        });
        support.funcNames = typeof Function.name == "string";
        support.nonEnumArgs = key != 0;
        support.nonEnumShadows = !/valueOf/.test(props);
        support.ownLast = props[0] != "x";
        support.spliceObjects = (arrayRef.splice.call(object, 0, 1), !object[0]);
        support.unindexedChars = "x"[0] + Object("x")[0] != "xx";
        try {
          support.nodeClass = !(toString.call(document) == objectClass && !({ "toString": 0 } + ""));
        } catch (e) {
          support.nodeClass = true;
        }
      })(1);
      var iteratorTemplate = function(obj) {
        var __p = "var index, iterable = " + obj.firstArg + ", result = " + obj.init + ";\nif (!iterable) return result;\n" + obj.top + ";";
        if (obj.array) {
          __p += "\nvar length = iterable.length; index = -1;\nif (" + obj.array + ") {  ";
          if (support.unindexedChars) {
            __p += "\n  if (isString(iterable)) {\n    iterable = iterable.split('')\n  }  ";
          }
          __p += "\n  while (++index < length) {\n    " + obj.loop + ";\n  }\n}\nelse {  ";
        } else if (support.nonEnumArgs) {
          __p += "\n  var length = iterable.length; index = -1;\n  if (length && isArguments(iterable)) {\n    while (++index < length) {\n      index += '';\n      " + obj.loop + ";\n    }\n  } else {  ";
        }
        if (support.enumPrototypes) {
          __p += "\n  var skipProto = typeof iterable == 'function';\n  ";
        }
        if (support.enumErrorProps) {
          __p += "\n  var skipErrorProps = iterable === errorProto || iterable instanceof Error;\n  ";
        }
        var conditions = [];
        if (support.enumPrototypes) {
          conditions.push('!(skipProto && index == "prototype")');
        }
        if (support.enumErrorProps) {
          conditions.push('!(skipErrorProps && (index == "message" || index == "name"))');
        }
        if (obj.useHas && obj.keys) {
          __p += "\n  var ownIndex = -1,\n      ownProps = objectTypes[typeof iterable] && keys(iterable),\n      length = ownProps ? ownProps.length : 0;\n\n  while (++ownIndex < length) {\n    index = ownProps[ownIndex];\n";
          if (conditions.length) {
            __p += "    if (" + conditions.join(" && ") + ") {\n  ";
          }
          __p += obj.loop + ";    ";
          if (conditions.length) {
            __p += "\n    }";
          }
          __p += "\n  }  ";
        } else {
          __p += "\n  for (index in iterable) {\n";
          if (obj.useHas) {
            conditions.push("hasOwnProperty.call(iterable, index)");
          }
          if (conditions.length) {
            __p += "    if (" + conditions.join(" && ") + ") {\n  ";
          }
          __p += obj.loop + ";    ";
          if (conditions.length) {
            __p += "\n    }";
          }
          __p += "\n  }    ";
          if (support.nonEnumShadows) {
            __p += "\n\n  if (iterable !== objectProto) {\n    var ctor = iterable.constructor,\n        isProto = iterable === (ctor && ctor.prototype),\n        className = iterable === stringProto ? stringClass : iterable === errorProto ? errorClass : toString.call(iterable),\n        nonEnum = nonEnumProps[className];\n      ";
            for (k = 0; k < 7; k++) {
              __p += "\n    index = '" + obj.shadowedProps[k] + "';\n    if ((!(isProto && nonEnum[index]) && hasOwnProperty.call(iterable, index))";
              if (!obj.useHas) {
                __p += " || (!nonEnum[index] && iterable[index] !== objectProto[index])";
              }
              __p += ") {\n      " + obj.loop + ";\n    }      ";
            }
            __p += "\n  }    ";
          }
        }
        if (obj.array || support.nonEnumArgs) {
          __p += "\n}";
        }
        __p += obj.bottom + ";\nreturn result";
        return __p;
      };
      function baseBind(bindData) {
        var func = bindData[0], partialArgs = bindData[2], thisArg = bindData[4];
        function bound() {
          if (partialArgs) {
            var args = slice(partialArgs);
            push.apply(args, arguments);
          }
          if (this instanceof bound) {
            var thisBinding = baseCreate(func.prototype), result = func.apply(thisBinding, args || arguments);
            return isObject(result) ? result : thisBinding;
          }
          return func.apply(thisArg, args || arguments);
        }
        setBindData(bound, bindData);
        return bound;
      }
      function baseClone(value, isDeep, callback, stackA, stackB) {
        if (callback) {
          var result = callback(value);
          if (typeof result != "undefined") {
            return result;
          }
        }
        var isObj = isObject(value);
        if (isObj) {
          var className = toString.call(value);
          if (!cloneableClasses[className] || !support.nodeClass && isNode(value)) {
            return value;
          }
          var ctor = ctorByClass[className];
          switch (className) {
            case boolClass:
            case dateClass:
              return new ctor(+value);
            case numberClass:
            case stringClass:
              return new ctor(value);
            case regexpClass:
              result = ctor(value.source, reFlags.exec(value));
              result.lastIndex = value.lastIndex;
              return result;
          }
        } else {
          return value;
        }
        var isArr = isArray(value);
        if (isDeep) {
          var initedStack = !stackA;
          stackA || (stackA = getArray());
          stackB || (stackB = getArray());
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == value) {
              return stackB[length];
            }
          }
          result = isArr ? ctor(value.length) : {};
        } else {
          result = isArr ? slice(value) : assign({}, value);
        }
        if (isArr) {
          if (hasOwnProperty.call(value, "index")) {
            result.index = value.index;
          }
          if (hasOwnProperty.call(value, "input")) {
            result.input = value.input;
          }
        }
        if (!isDeep) {
          return result;
        }
        stackA.push(value);
        stackB.push(result);
        (isArr ? baseEach : forOwn)(value, function(objValue, key) {
          result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
        });
        if (initedStack) {
          releaseArray(stackA);
          releaseArray(stackB);
        }
        return result;
      }
      function baseCreate(prototype, properties) {
        return isObject(prototype) ? nativeCreate(prototype) : {};
      }
      if (!nativeCreate) {
        baseCreate = /* @__PURE__ */ function() {
          function Object2() {
          }
          return function(prototype) {
            if (isObject(prototype)) {
              Object2.prototype = prototype;
              var result = new Object2();
              Object2.prototype = null;
            }
            return result || root.Object();
          };
        }();
      }
      function baseCreateCallback(func, thisArg, argCount) {
        if (typeof func != "function") {
          return identity;
        }
        if (typeof thisArg == "undefined" || !("prototype" in func)) {
          return func;
        }
        var bindData = func.__bindData__;
        if (typeof bindData == "undefined") {
          if (support.funcNames) {
            bindData = !func.name;
          }
          bindData = bindData || !support.funcDecomp;
          if (!bindData) {
            var source = fnToString.call(func);
            if (!support.funcNames) {
              bindData = !reFuncName.test(source);
            }
            if (!bindData) {
              bindData = reThis.test(source);
              setBindData(func, bindData);
            }
          }
        }
        if (bindData === false || bindData !== true && bindData[1] & 1) {
          return func;
        }
        switch (argCount) {
          case 1:
            return function(value) {
              return func.call(thisArg, value);
            };
          case 2:
            return function(a, b) {
              return func.call(thisArg, a, b);
            };
          case 3:
            return function(value, index, collection) {
              return func.call(thisArg, value, index, collection);
            };
          case 4:
            return function(accumulator, value, index, collection) {
              return func.call(thisArg, accumulator, value, index, collection);
            };
        }
        return bind(func, thisArg);
      }
      function baseCreateWrapper(bindData) {
        var func = bindData[0], bitmask = bindData[1], partialArgs = bindData[2], partialRightArgs = bindData[3], thisArg = bindData[4], arity = bindData[5];
        var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, key = func;
        function bound() {
          var thisBinding = isBind ? thisArg : this;
          if (partialArgs) {
            var args = slice(partialArgs);
            push.apply(args, arguments);
          }
          if (partialRightArgs || isCurry) {
            args || (args = slice(arguments));
            if (partialRightArgs) {
              push.apply(args, partialRightArgs);
            }
            if (isCurry && args.length < arity) {
              bitmask |= 16 & ~32;
              return baseCreateWrapper([func, isCurryBound ? bitmask : bitmask & ~3, args, null, thisArg, arity]);
            }
          }
          args || (args = arguments);
          if (isBindKey) {
            func = thisBinding[key];
          }
          if (this instanceof bound) {
            thisBinding = baseCreate(func.prototype);
            var result = func.apply(thisBinding, args);
            return isObject(result) ? result : thisBinding;
          }
          return func.apply(thisBinding, args);
        }
        setBindData(bound, bindData);
        return bound;
      }
      function baseMerge(object, source, callback, stackA, stackB) {
        (isArray(source) ? forEach : forOwn)(source, function(source2, key) {
          var found, isArr, result = source2, value = object[key];
          if (source2 && ((isArr = isArray(source2)) || isPlainObject(source2))) {
            var stackLength = stackA.length;
            while (stackLength--) {
              if (found = stackA[stackLength] == source2) {
                value = stackB[stackLength];
                break;
              }
            }
            if (!found) {
              var isShallow;
              if (callback) {
                result = callback(value, source2);
                if (isShallow = typeof result != "undefined") {
                  value = result;
                }
              }
              if (!isShallow) {
                value = isArr ? isArray(value) ? value : [] : isPlainObject(value) ? value : {};
              }
              stackA.push(source2);
              stackB.push(value);
              if (!isShallow) {
                baseMerge(value, source2, callback, stackA, stackB);
              }
            }
          } else {
            if (callback) {
              result = callback(value, source2);
              if (typeof result == "undefined") {
                result = source2;
              }
            }
            if (typeof result != "undefined") {
              value = result;
            }
          }
          object[key] = value;
        });
      }
      function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
        var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, isPartial = bitmask & 16, isPartialRight = bitmask & 32;
        if (!isBindKey && !isFunction(func)) {
          throw new TypeError();
        }
        if (isPartial && !partialArgs.length) {
          bitmask &= ~16;
          isPartial = partialArgs = false;
        }
        if (isPartialRight && !partialRightArgs.length) {
          bitmask &= ~32;
          isPartialRight = partialRightArgs = false;
        }
        var bindData = func && func.__bindData__;
        if (bindData && bindData !== true) {
          bindData = slice(bindData);
          if (bindData[2]) {
            bindData[2] = slice(bindData[2]);
          }
          if (bindData[3]) {
            bindData[3] = slice(bindData[3]);
          }
          if (isBind && !(bindData[1] & 1)) {
            bindData[4] = thisArg;
          }
          if (!isBind && bindData[1] & 1) {
            bitmask |= 8;
          }
          if (isCurry && !(bindData[1] & 4)) {
            bindData[5] = arity;
          }
          if (isPartial) {
            push.apply(bindData[2] || (bindData[2] = []), partialArgs);
          }
          if (isPartialRight) {
            unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
          }
          bindData[1] |= bitmask;
          return createWrapper.apply(null, bindData);
        }
        var creater = bitmask == 1 || bitmask === 17 ? baseBind : baseCreateWrapper;
        return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
      }
      function createIterator() {
        iteratorData.shadowedProps = shadowedProps;
        iteratorData.array = iteratorData.bottom = iteratorData.loop = iteratorData.top = "";
        iteratorData.init = "iterable";
        iteratorData.useHas = true;
        for (var object, index = 0; object = arguments[index]; index++) {
          for (var key in object) {
            iteratorData[key] = object[key];
          }
        }
        var args = iteratorData.args;
        iteratorData.firstArg = /^[^,]+/.exec(args)[0];
        var factory = Function(
          "baseCreateCallback, errorClass, errorProto, hasOwnProperty, indicatorObject, isArguments, isArray, isString, keys, objectProto, objectTypes, nonEnumProps, stringClass, stringProto, toString",
          "return function(" + args + ") {\n" + iteratorTemplate(iteratorData) + "\n}"
        );
        return factory(
          baseCreateCallback,
          errorClass,
          errorProto,
          hasOwnProperty,
          indicatorObject,
          isArguments,
          isArray,
          isString,
          iteratorData.keys,
          objectProto,
          objectTypes,
          nonEnumProps,
          stringClass,
          stringProto,
          toString
        );
      }
      function isNative(value) {
        return typeof value == "function" && reNative.test(value);
      }
      var setBindData = !defineProperty ? noop : function(func, value) {
        descriptor.value = value;
        defineProperty(func, "__bindData__", descriptor);
      };
      function shimIsPlainObject(value) {
        var ctor, result;
        if (!(value && toString.call(value) == objectClass) || (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor)) || !support.argsClass && isArguments(value) || !support.nodeClass && isNode(value)) {
          return false;
        }
        if (support.ownLast) {
          forIn(value, function(value2, key, object) {
            result = hasOwnProperty.call(object, key);
            return false;
          });
          return result !== false;
        }
        forIn(value, function(value2, key) {
          result = key;
        });
        return typeof result == "undefined" || hasOwnProperty.call(value, result);
      }
      function isArguments(value) {
        return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == argsClass || false;
      }
      if (!support.argsClass) {
        isArguments = function(value) {
          return value && typeof value == "object" && typeof value.length == "number" && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee") || false;
        };
      }
      var isArray = nativeIsArray || function(value) {
        return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == arrayClass || false;
      };
      var shimKeys = createIterator({
        "args": "object",
        "init": "[]",
        "top": "if (!(objectTypes[typeof object])) return result",
        "loop": "result.push(index)"
      });
      var keys = !nativeKeys ? shimKeys : function(object) {
        if (!isObject(object)) {
          return [];
        }
        if (support.enumPrototypes && typeof object == "function" || support.nonEnumArgs && object.length && isArguments(object)) {
          return shimKeys(object);
        }
        return nativeKeys(object);
      };
      var eachIteratorOptions = {
        "args": "collection, callback, thisArg",
        "top": "callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3)",
        "array": "typeof length == 'number'",
        "keys": keys,
        "loop": "if (callback(iterable[index], index, collection) === false) return result"
      };
      var defaultsIteratorOptions = {
        "args": "object, source, guard",
        "top": "var args = arguments,\n    argsIndex = 0,\n    argsLength = typeof guard == 'number' ? 2 : args.length;\nwhile (++argsIndex < argsLength) {\n  iterable = args[argsIndex];\n  if (iterable && objectTypes[typeof iterable]) {",
        "keys": keys,
        "loop": "if (typeof result[index] == 'undefined') result[index] = iterable[index]",
        "bottom": "  }\n}"
      };
      var forOwnIteratorOptions = {
        "top": "if (!objectTypes[typeof iterable]) return result;\n" + eachIteratorOptions.top,
        "array": false
      };
      var baseEach = createIterator(eachIteratorOptions);
      var assign = createIterator(defaultsIteratorOptions, {
        "top": defaultsIteratorOptions.top.replace(
          ";",
          ";\nif (argsLength > 3 && typeof args[argsLength - 2] == 'function') {\n  var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);\n} else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {\n  callback = args[--argsLength];\n}"
        ),
        "loop": "result[index] = callback ? callback(result[index], iterable[index]) : iterable[index]"
      });
      function clone(value, isDeep, callback, thisArg) {
        if (typeof isDeep != "boolean" && isDeep != null) {
          thisArg = callback;
          callback = isDeep;
          isDeep = false;
        }
        return baseClone(value, isDeep, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1));
      }
      var forIn = createIterator(eachIteratorOptions, forOwnIteratorOptions, {
        "useHas": false
      });
      var forOwn = createIterator(eachIteratorOptions, forOwnIteratorOptions);
      function isEmpty(value) {
        var result = true;
        if (!value) {
          return result;
        }
        var className = toString.call(value), length = value.length;
        if (className == arrayClass || className == stringClass || (support.argsClass ? className == argsClass : isArguments(value)) || className == objectClass && typeof length == "number" && isFunction(value.splice)) {
          return !length;
        }
        forOwn(value, function() {
          return result = false;
        });
        return result;
      }
      function isFunction(value) {
        return typeof value == "function";
      }
      if (isFunction(/x/)) {
        isFunction = function(value) {
          return typeof value == "function" && toString.call(value) == funcClass;
        };
      }
      function isObject(value) {
        return !!(value && objectTypes[typeof value]);
      }
      var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
        if (!(value && toString.call(value) == objectClass) || !support.argsClass && isArguments(value)) {
          return false;
        }
        var valueOf = value.valueOf, objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
        return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
      };
      function isString(value) {
        return typeof value == "string" || value && typeof value == "object" && toString.call(value) == stringClass || false;
      }
      function merge(object) {
        var args = arguments, length = 2;
        if (!isObject(object)) {
          return object;
        }
        if (typeof args[2] != "number") {
          length = args.length;
        }
        if (length > 3 && typeof args[length - 2] == "function") {
          var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
        } else if (length > 2 && typeof args[length - 1] == "function") {
          callback = args[--length];
        }
        var sources = slice(arguments, 1, length), index = -1, stackA = getArray(), stackB = getArray();
        while (++index < length) {
          baseMerge(object, sources[index], callback, stackA, stackB);
        }
        releaseArray(stackA);
        releaseArray(stackB);
        return object;
      }
      function forEach(collection, callback, thisArg) {
        if (callback && typeof thisArg == "undefined" && isArray(collection)) {
          var index = -1, length = collection.length;
          while (++index < length) {
            if (callback(collection[index], index, collection) === false) {
              break;
            }
          }
        } else {
          baseEach(collection, callback, thisArg);
        }
        return collection;
      }
      function compact(array) {
        var index = -1, length = array ? array.length : 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value) {
            result.push(value);
          }
        }
        return result;
      }
      function bind(func, thisArg) {
        return arguments.length > 2 ? createWrapper(func, 17, slice(arguments, 2), null, thisArg) : createWrapper(func, 1, null, null, thisArg);
      }
      function identity(value) {
        return value;
      }
      function noop() {
      }
      lodash.assign = assign;
      lodash.bind = bind;
      lodash.compact = compact;
      lodash.forEach = forEach;
      lodash.forIn = forIn;
      lodash.forOwn = forOwn;
      lodash.keys = keys;
      lodash.merge = merge;
      lodash.each = forEach;
      lodash.extend = assign;
      lodash.clone = clone;
      lodash.identity = identity;
      lodash.isArguments = isArguments;
      lodash.isArray = isArray;
      lodash.isEmpty = isEmpty;
      lodash.isFunction = isFunction;
      lodash.isObject = isObject;
      lodash.isPlainObject = isPlainObject;
      lodash.isString = isString;
      lodash.noop = noop;
      lodash.VERSION = "2.4.1";
      if (freeExports && freeModule) {
        if (moduleExports) {
          (freeModule.exports = lodash)._ = lodash;
        }
      }
    }).call(exports);
  }
});

// node_modules/wgs84/index.js
var require_wgs84 = __commonJS({
  "node_modules/wgs84/index.js"(exports, module) {
    module.exports.RADIUS = 6378137;
    module.exports.FLATTENING = 1 / 298.257223563;
    module.exports.POLAR_RADIUS = 63567523142e-4;
  }
});

// node_modules/geojson-area/index.js
var require_geojson_area = __commonJS({
  "node_modules/geojson-area/index.js"(exports, module) {
    var wgs84 = require_wgs84();
    module.exports.geometry = geometry;
    module.exports.ring = ringArea;
    function geometry(_) {
      if (_.type === "Polygon") return polygonArea(_.coordinates);
      else if (_.type === "MultiPolygon") {
        var area = 0;
        for (var i = 0; i < _.coordinates.length; i++) {
          area += polygonArea(_.coordinates[i]);
        }
        return area;
      } else {
        return null;
      }
    }
    function polygonArea(coords) {
      var area = 0;
      if (coords && coords.length > 0) {
        area += Math.abs(ringArea(coords[0]));
        for (var i = 1; i < coords.length; i++) {
          area -= Math.abs(ringArea(coords[i]));
        }
      }
      return area;
    }
    function ringArea(coords) {
      var area = 0;
      if (coords.length > 2) {
        var p1, p2;
        for (var i = 0; i < coords.length - 1; i++) {
          p1 = coords[i];
          p2 = coords[i + 1];
          area += rad(p2[0] - p1[0]) * (2 + Math.sin(rad(p1[1])) + Math.sin(rad(p2[1])));
        }
        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;
      }
      return area;
    }
    function rad(_) {
      return _ * Math.PI / 180;
    }
  }
});

// node_modules/geojson-rewind/index.js
var require_geojson_rewind = __commonJS({
  "node_modules/geojson-rewind/index.js"(exports, module) {
    var geojsonArea = require_geojson_area();
    module.exports = rewind;
    function rewind(gj, outer) {
      switch (gj && gj.type || null) {
        case "FeatureCollection":
          gj.features = gj.features.map(curryOuter(rewind, outer));
          return gj;
        case "Feature":
          gj.geometry = rewind(gj.geometry, outer);
          return gj;
        case "Polygon":
        case "MultiPolygon":
          return correct(gj, outer);
        default:
          return gj;
      }
    }
    function curryOuter(a, b) {
      return function(_) {
        return a(_, b);
      };
    }
    function correct(_, outer) {
      if (_.type === "Polygon") {
        _.coordinates = correctRings(_.coordinates, outer);
      } else if (_.type === "MultiPolygon") {
        _.coordinates = _.coordinates.map(curryOuter(correctRings, outer));
      }
      return _;
    }
    function correctRings(_, outer) {
      outer = !!outer;
      _[0] = wind(_[0], !outer);
      for (var i = 1; i < _.length; i++) {
        _[i] = wind(_[i], outer);
      }
      return _;
    }
    function wind(_, dir) {
      return cw(_) === dir ? _ : _.reverse();
    }
    function cw(_) {
      return geojsonArea.ring(_) >= 0;
    }
  }
});

// node_modules/osm-polygon-features/polygon-features.json
var require_polygon_features = __commonJS({
  "node_modules/osm-polygon-features/polygon-features.json"(exports, module) {
    module.exports = [
      {
        key: "building",
        polygon: "all"
      },
      {
        key: "highway",
        polygon: "whitelist",
        values: [
          "services",
          "rest_area",
          "escape",
          "elevator"
        ]
      },
      {
        key: "natural",
        polygon: "blacklist",
        values: [
          "coastline",
          "cliff",
          "ridge",
          "arete",
          "tree_row"
        ]
      },
      {
        key: "landuse",
        polygon: "all"
      },
      {
        key: "waterway",
        polygon: "whitelist",
        values: [
          "riverbank",
          "dock",
          "boatyard",
          "dam"
        ]
      },
      {
        key: "amenity",
        polygon: "all"
      },
      {
        key: "leisure",
        polygon: "all"
      },
      {
        key: "barrier",
        polygon: "whitelist",
        values: [
          "city_wall",
          "ditch",
          "hedge",
          "retaining_wall",
          "wall",
          "spikes"
        ]
      },
      {
        key: "railway",
        polygon: "whitelist",
        values: [
          "station",
          "turntable",
          "roundhouse",
          "platform"
        ]
      },
      {
        key: "area",
        polygon: "all"
      },
      {
        key: "boundary",
        polygon: "all"
      },
      {
        key: "man_made",
        polygon: "blacklist",
        values: [
          "cutline",
          "embankment",
          "pipeline"
        ]
      },
      {
        key: "power",
        polygon: "whitelist",
        values: [
          "plant",
          "substation",
          "generator",
          "transformer"
        ]
      },
      {
        key: "place",
        polygon: "all"
      },
      {
        key: "shop",
        polygon: "all"
      },
      {
        key: "aeroway",
        polygon: "blacklist",
        values: [
          "taxiway"
        ]
      },
      {
        key: "tourism",
        polygon: "all"
      },
      {
        key: "historic",
        polygon: "all"
      },
      {
        key: "public_transport",
        polygon: "all"
      },
      {
        key: "office",
        polygon: "all"
      },
      {
        key: "building:part",
        polygon: "all"
      },
      {
        key: "military",
        polygon: "all"
      },
      {
        key: "ruins",
        polygon: "all"
      },
      {
        key: "area:highway",
        polygon: "all"
      },
      {
        key: "craft",
        polygon: "all"
      },
      {
        key: "golf",
        polygon: "all"
      },
      {
        key: "indoor",
        polygon: "all"
      }
    ];
  }
});

// node_modules/osm-polygon-features/index.js
var require_osm_polygon_features = __commonJS({
  "node_modules/osm-polygon-features/index.js"(exports, module) {
    module.exports = require_polygon_features();
  }
});

// node_modules/osmtogeojson/index.js
var require_osmtogeojson = __commonJS({
  "node_modules/osmtogeojson/index.js"(exports, module) {
    var _ = require_lodash_custom();
    var rewind = require_geojson_rewind();
    var polygonFeatures = {};
    require_osm_polygon_features().forEach(function(tags) {
      if (tags.polygon === "all")
        polygonFeatures[tags.key] = true;
      else {
        var list = tags.polygon === "whitelist" ? "included_values" : "excluded_values", tagValuesObj = {};
        tags.values.forEach(function(value) {
          tagValuesObj[value] = true;
        });
        polygonFeatures[tags.key] = {};
        polygonFeatures[tags.key][list] = tagValuesObj;
      }
    });
    var osmtogeojson = {};
    osmtogeojson = function(data, options) {
      options = _.merge(
        {
          verbose: false,
          flatProperties: false,
          uninterestingTags: {
            "source": true,
            "source_ref": true,
            "source:ref": true,
            "history": true,
            "attribution": true,
            "created_by": true,
            "tiger:county": true,
            "tiger:tlid": true,
            "tiger:upload_uuid": true
          },
          polygonFeatures
        },
        options
      );
      var result;
      if (typeof XMLDocument !== "undefined" && data instanceof XMLDocument || typeof XMLDocument === "undefined" && data.childNodes)
        result = _osmXML2geoJSON(data);
      else
        result = _overpassJSON2geoJSON(data);
      return result;
      function _overpassJSON2geoJSON(json) {
        var nodes = new Array();
        var ways = new Array();
        var rels = new Array();
        function centerGeometry(object) {
          var pseudoNode = _.clone(object);
          pseudoNode.lat = object.center.lat;
          pseudoNode.lon = object.center.lon;
          pseudoNode.__is_center_placeholder = true;
          nodes.push(pseudoNode);
        }
        function boundsGeometry(object) {
          var pseudoWay = _.clone(object);
          pseudoWay.nodes = [];
          function addPseudoNode(lat, lon, i2) {
            var pseudoNode = {
              type: "node",
              id: "_" + pseudoWay.type + "/" + pseudoWay.id + "bounds" + i2,
              lat,
              lon
            };
            pseudoWay.nodes.push(pseudoNode.id);
            nodes.push(pseudoNode);
          }
          addPseudoNode(pseudoWay.bounds.minlat, pseudoWay.bounds.minlon, 1);
          addPseudoNode(pseudoWay.bounds.maxlat, pseudoWay.bounds.minlon, 2);
          addPseudoNode(pseudoWay.bounds.maxlat, pseudoWay.bounds.maxlon, 3);
          addPseudoNode(pseudoWay.bounds.minlat, pseudoWay.bounds.maxlon, 4);
          pseudoWay.nodes.push(pseudoWay.nodes[0]);
          pseudoWay.__is_bounds_placeholder = true;
          ways.push(pseudoWay);
        }
        function fullGeometryWay(way2) {
          function addFullGeometryNode(lat, lon, id) {
            var geometryNode = {
              type: "node",
              id,
              lat,
              lon,
              __is_uninteresting: true
            };
            nodes.push(geometryNode);
          }
          if (!_.isArray(way2.nodes)) {
            way2.nodes = way2.geometry.map(function(nd) {
              if (nd !== null)
                return "_anonymous@" + nd.lat + "/" + nd.lon;
              else
                return "_anonymous@unknown_location";
            });
          }
          way2.geometry.forEach(function(nd, i2) {
            if (nd) {
              addFullGeometryNode(
                nd.lat,
                nd.lon,
                way2.nodes[i2]
              );
            }
          });
        }
        function fullGeometryRelation(rel2) {
          function addFullGeometryNode(lat, lon, id) {
            var geometryNode = {
              type: "node",
              id,
              lat,
              lon
            };
            nodes.push(geometryNode);
          }
          function addFullGeometryWay(geometry, id) {
            if (ways.some(function(way2) {
              return way2.type == "way" && way2.id == id;
            })) return;
            var geometryWay = {
              type: "way",
              id,
              nodes: []
            };
            function addFullGeometryWayPseudoNode(lat, lon) {
              var geometryPseudoNode = {
                type: "node",
                id: "_anonymous@" + lat + "/" + lon,
                lat,
                lon,
                __is_uninteresting: true
              };
              geometryWay.nodes.push(geometryPseudoNode.id);
              nodes.push(geometryPseudoNode);
            }
            geometry.forEach(function(nd) {
              if (nd) {
                addFullGeometryWayPseudoNode(
                  nd.lat,
                  nd.lon
                );
              } else {
                geometryWay.nodes.push(void 0);
              }
            });
            ways.push(geometryWay);
          }
          rel2.members.forEach(function(member, i2) {
            if (member.type == "node") {
              if (member.lat) {
                addFullGeometryNode(
                  member.lat,
                  member.lon,
                  member.ref
                );
              }
            } else if (member.type == "way") {
              if (member.geometry) {
                member.ref = "_fullGeom" + member.ref;
                addFullGeometryWay(
                  member.geometry,
                  member.ref
                );
              }
            }
          });
        }
        for (var i = 0; i < json.elements.length; i++) {
          switch (json.elements[i].type) {
            case "node":
              var node = json.elements[i];
              nodes.push(node);
              break;
            case "way":
              var way = _.clone(json.elements[i]);
              way.nodes = _.clone(way.nodes);
              ways.push(way);
              if (way.center)
                centerGeometry(way);
              if (way.geometry)
                fullGeometryWay(way);
              else if (way.bounds)
                boundsGeometry(way);
              break;
            case "relation":
              var rel = _.clone(json.elements[i]);
              rel.members = _.clone(rel.members);
              rels.push(rel);
              var has_full_geometry = rel.members && rel.members.some(function(member) {
                return member.type == "node" && member.lat || member.type == "way" && member.geometry && member.geometry.length > 0;
              });
              if (rel.center)
                centerGeometry(rel);
              if (has_full_geometry)
                fullGeometryRelation(rel);
              else if (rel.bounds)
                boundsGeometry(rel);
              break;
            default:
          }
        }
        return _convert2geoJSON(nodes, ways, rels);
      }
      function _osmXML2geoJSON(xml) {
        var nodes = new Array();
        var ways = new Array();
        var rels = new Array();
        function copy_attribute(x, o, attr) {
          if (x.hasAttribute(attr))
            o[attr] = x.getAttribute(attr);
        }
        function centerGeometry(object, centroid2) {
          var pseudoNode = _.clone(object);
          copy_attribute(centroid2, pseudoNode, "lat");
          copy_attribute(centroid2, pseudoNode, "lon");
          pseudoNode.__is_center_placeholder = true;
          nodes.push(pseudoNode);
        }
        function boundsGeometry(object, bounds2) {
          var pseudoWay = _.clone(object);
          pseudoWay.nodes = [];
          function addPseudoNode(lat, lon, i) {
            var pseudoNode = {
              type: "node",
              id: "_" + pseudoWay.type + "/" + pseudoWay.id + "bounds" + i,
              lat,
              lon
            };
            pseudoWay.nodes.push(pseudoNode.id);
            nodes.push(pseudoNode);
          }
          addPseudoNode(bounds2.getAttribute("minlat"), bounds2.getAttribute("minlon"), 1);
          addPseudoNode(bounds2.getAttribute("maxlat"), bounds2.getAttribute("minlon"), 2);
          addPseudoNode(bounds2.getAttribute("maxlat"), bounds2.getAttribute("maxlon"), 3);
          addPseudoNode(bounds2.getAttribute("minlat"), bounds2.getAttribute("maxlon"), 4);
          pseudoWay.nodes.push(pseudoWay.nodes[0]);
          pseudoWay.__is_bounds_placeholder = true;
          ways.push(pseudoWay);
        }
        function fullGeometryWay(way, nds) {
          function addFullGeometryNode(lat, lon, id) {
            var geometryNode = {
              type: "node",
              id,
              lat,
              lon,
              __is_uninteresting: true
            };
            nodes.push(geometryNode);
            return geometryNode.id;
          }
          if (!_.isArray(way.nodes)) {
            way.nodes = [];
            _.each(nds, function(nd, i) {
              way.nodes.push("_anonymous@" + nd.getAttribute("lat") + "/" + nd.getAttribute("lon"));
            });
          }
          _.each(nds, function(nd, i) {
            if (nd.getAttribute("lat")) {
              addFullGeometryNode(
                nd.getAttribute("lat"),
                nd.getAttribute("lon"),
                way.nodes[i]
              );
            }
          });
        }
        function fullGeometryRelation(rel, members) {
          function addFullGeometryNode(lat, lon, id) {
            var geometryNode = {
              type: "node",
              id,
              lat,
              lon
            };
            nodes.push(geometryNode);
          }
          function addFullGeometryWay(nds, id) {
            if (ways.some(function(way) {
              return way.type == "way" && way.id == id;
            })) return;
            var geometryWay = {
              type: "way",
              id,
              nodes: []
            };
            function addFullGeometryWayPseudoNode(lat, lon) {
              var geometryPseudoNode = {
                type: "node",
                id: "_anonymous@" + lat + "/" + lon,
                lat,
                lon,
                __is_uninteresting: true
              };
              geometryWay.nodes.push(geometryPseudoNode.id);
              nodes.push(geometryPseudoNode);
            }
            _.each(nds, function(nd) {
              if (nd.getAttribute("lat")) {
                addFullGeometryWayPseudoNode(
                  nd.getAttribute("lat"),
                  nd.getAttribute("lon")
                );
              } else {
                geometryWay.nodes.push(void 0);
              }
            });
            ways.push(geometryWay);
          }
          _.each(members, function(member, i) {
            if (rel.members[i].type == "node") {
              if (member.getAttribute("lat")) {
                addFullGeometryNode(
                  member.getAttribute("lat"),
                  member.getAttribute("lon"),
                  rel.members[i].ref
                );
              }
            } else if (rel.members[i].type == "way") {
              if (member.getElementsByTagName("nd").length > 0) {
                rel.members[i].ref = "_fullGeom" + rel.members[i].ref;
                addFullGeometryWay(
                  member.getElementsByTagName("nd"),
                  rel.members[i].ref
                );
              }
            }
          });
        }
        _.each(xml.getElementsByTagName("node"), function(node, i) {
          var tags = {};
          _.each(node.getElementsByTagName("tag"), function(tag) {
            tags[tag.getAttribute("k")] = tag.getAttribute("v");
          });
          var nodeObject = {
            "type": "node"
          };
          copy_attribute(node, nodeObject, "id");
          copy_attribute(node, nodeObject, "lat");
          copy_attribute(node, nodeObject, "lon");
          copy_attribute(node, nodeObject, "version");
          copy_attribute(node, nodeObject, "timestamp");
          copy_attribute(node, nodeObject, "changeset");
          copy_attribute(node, nodeObject, "uid");
          copy_attribute(node, nodeObject, "user");
          if (!_.isEmpty(tags))
            nodeObject.tags = tags;
          nodes.push(nodeObject);
        });
        var centroid, bounds;
        _.each(xml.getElementsByTagName("way"), function(way, i) {
          var tags = {};
          var wnodes = [];
          _.each(way.getElementsByTagName("tag"), function(tag) {
            tags[tag.getAttribute("k")] = tag.getAttribute("v");
          });
          var has_full_geometry = false;
          _.each(way.getElementsByTagName("nd"), function(nd, i2) {
            var id;
            if (id = nd.getAttribute("ref"))
              wnodes[i2] = id;
            if (!has_full_geometry && nd.getAttribute("lat"))
              has_full_geometry = true;
          });
          var wayObject = {
            "type": "way"
          };
          copy_attribute(way, wayObject, "id");
          copy_attribute(way, wayObject, "version");
          copy_attribute(way, wayObject, "timestamp");
          copy_attribute(way, wayObject, "changeset");
          copy_attribute(way, wayObject, "uid");
          copy_attribute(way, wayObject, "user");
          if (wnodes.length > 0)
            wayObject.nodes = wnodes;
          if (!_.isEmpty(tags))
            wayObject.tags = tags;
          if (centroid = way.getElementsByTagName("center")[0])
            centerGeometry(wayObject, centroid);
          if (has_full_geometry)
            fullGeometryWay(wayObject, way.getElementsByTagName("nd"));
          else if (bounds = way.getElementsByTagName("bounds")[0])
            boundsGeometry(wayObject, bounds);
          ways.push(wayObject);
        });
        _.each(xml.getElementsByTagName("relation"), function(relation, i) {
          var tags = {};
          var members = [];
          _.each(relation.getElementsByTagName("tag"), function(tag) {
            tags[tag.getAttribute("k")] = tag.getAttribute("v");
          });
          var has_full_geometry = false;
          _.each(relation.getElementsByTagName("member"), function(member, i2) {
            members[i2] = {};
            copy_attribute(member, members[i2], "ref");
            copy_attribute(member, members[i2], "role");
            copy_attribute(member, members[i2], "type");
            if (!has_full_geometry && (members[i2].type == "node" && member.getAttribute("lat")) || members[i2].type == "way" && member.getElementsByTagName("nd").length > 0)
              has_full_geometry = true;
          });
          var relObject = {
            "type": "relation"
          };
          copy_attribute(relation, relObject, "id");
          copy_attribute(relation, relObject, "version");
          copy_attribute(relation, relObject, "timestamp");
          copy_attribute(relation, relObject, "changeset");
          copy_attribute(relation, relObject, "uid");
          copy_attribute(relation, relObject, "user");
          if (members.length > 0)
            relObject.members = members;
          if (!_.isEmpty(tags))
            relObject.tags = tags;
          if (centroid = relation.getElementsByTagName("center")[0])
            centerGeometry(relObject, centroid);
          if (has_full_geometry)
            fullGeometryRelation(relObject, relation.getElementsByTagName("member"));
          else if (bounds = relation.getElementsByTagName("bounds")[0])
            boundsGeometry(relObject, bounds);
          rels.push(relObject);
        });
        return _convert2geoJSON(nodes, ways, rels);
      }
      function _convert2geoJSON(nodes, ways, rels) {
        function has_interesting_tags(t, ignore_tags) {
          if (typeof ignore_tags !== "object")
            ignore_tags = {};
          if (typeof options.uninterestingTags === "function")
            return !options.uninterestingTags(t, ignore_tags);
          for (var k2 in t)
            if (!(options.uninterestingTags[k2] === true) && !(ignore_tags[k2] === true || ignore_tags[k2] === t[k2]))
              return true;
          return false;
        }
        ;
        function build_meta_information(object) {
          var res = {
            "timestamp": object.timestamp,
            "version": object.version,
            "changeset": object.changeset,
            "user": object.user,
            "uid": object.uid
          };
          for (var k2 in res)
            if (res[k2] === void 0)
              delete res[k2];
          return res;
        }
        var nodeids = new Object();
        for (var i = 0; i < nodes.length; i++) {
          if (nodes[i].lat === void 0) {
            if (options.verbose) console.warn("Node", nodes[i].type + "/" + nodes[i].id, "ignored because it has no coordinates");
            continue;
          }
          nodeids[nodes[i].id] = nodes[i];
        }
        var poinids = new Object();
        for (var i = 0; i < nodes.length; i++) {
          if (typeof nodes[i].tags != "undefined" && has_interesting_tags(nodes[i].tags))
            poinids[nodes[i].id] = true;
        }
        for (var i = 0; i < rels.length; i++) {
          if (!_.isArray(rels[i].members)) {
            if (options.verbose) console.warn("Relation", rels[i].type + "/" + rels[i].id, "ignored because it has no members");
            continue;
          }
          for (var j = 0; j < rels[i].members.length; j++) {
            if (rels[i].members[j].type == "node")
              poinids[rels[i].members[j].ref] = true;
          }
        }
        var wayids = new Object();
        var waynids = new Object();
        for (var i = 0; i < ways.length; i++) {
          if (!_.isArray(ways[i].nodes)) {
            if (options.verbose) console.warn("Way", ways[i].type + "/" + ways[i].id, "ignored because it has no nodes");
            continue;
          }
          wayids[ways[i].id] = ways[i];
          for (var j = 0; j < ways[i].nodes.length; j++) {
            waynids[ways[i].nodes[j]] = true;
            ways[i].nodes[j] = nodeids[ways[i].nodes[j]];
          }
        }
        var pois = new Array();
        for (var i = 0; i < nodes.length; i++) {
          if ((!waynids[nodes[i].id] || poinids[nodes[i].id]) && !nodes[i].__is_uninteresting)
            pois.push(nodes[i]);
        }
        var relids = new Array();
        for (var i = 0; i < rels.length; i++) {
          if (!_.isArray(rels[i].members)) {
            if (options.verbose) console.warn("Relation", rels[i].type + "/" + rels[i].id, "ignored because it has no members");
            continue;
          }
          relids[rels[i].id] = rels[i];
        }
        var relsmap = { node: {}, way: {}, relation: {} };
        for (var i = 0; i < rels.length; i++) {
          if (!_.isArray(rels[i].members)) {
            if (options.verbose) console.warn("Relation", rels[i].type + "/" + rels[i].id, "ignored because it has no members");
            continue;
          }
          for (var j = 0; j < rels[i].members.length; j++) {
            var m_type = rels[i].members[j].type;
            var m_ref = rels[i].members[j].ref;
            if (typeof m_ref !== "number") {
              m_ref = m_ref.replace("_fullGeom", "");
            }
            if (!relsmap[m_type]) {
              if (options.verbose) console.warn("Relation", rels[i].type + "/" + rels[i].id, "member", m_type + "/" + m_ref, "ignored because it has an invalid type");
              continue;
            }
            if (typeof relsmap[m_type][m_ref] === "undefined")
              relsmap[m_type][m_ref] = [];
            relsmap[m_type][m_ref].push({
              "role": rels[i].members[j].role,
              "rel": rels[i].id,
              "reltags": rels[i].tags
            });
          }
        }
        var geojson;
        var geojsonnodes = {
          "type": "FeatureCollection",
          "features": new Array()
        };
        for (i = 0; i < pois.length; i++) {
          if (typeof pois[i].lon == "undefined" || typeof pois[i].lat == "undefined") {
            if (options.verbose) console.warn("POI", pois[i].type + "/" + pois[i].id, "ignored because it lacks coordinates");
            continue;
          }
          var feature = {
            "type": "Feature",
            "id": pois[i].type + "/" + pois[i].id,
            "properties": {
              "type": pois[i].type,
              "id": pois[i].id,
              "tags": pois[i].tags || {},
              "relations": relsmap["node"][pois[i].id] || [],
              "meta": build_meta_information(pois[i])
            },
            "geometry": {
              "type": "Point",
              "coordinates": [+pois[i].lon, +pois[i].lat]
            }
          };
          if (pois[i].__is_center_placeholder)
            feature.properties["geometry"] = "center";
          geojsonnodes.features.push(feature);
        }
        var geojsonlines = {
          "type": "FeatureCollection",
          "features": new Array()
        };
        var geojsonpolygons = {
          "type": "FeatureCollection",
          "features": new Array()
        };
        for (var i = 0; i < rels.length; i++) {
          if (typeof rels[i].tags != "undefined" && (rels[i].tags["type"] == "multipolygon" || rels[i].tags["type"] == "boundary")) {
            let construct_multipolygon2 = function(tag_object, rel) {
              var is_tainted = false;
              var mp_geometry2 = simple_mp ? "way" : "relation", mp_id = typeof tag_object.id === "number" ? tag_object.id : +tag_object.id.replace("_fullGeom", "");
              var members;
              members = rel.members.filter(function(m) {
                return m.type === "way";
              });
              members = members.map(function(m) {
                var way = wayids[m.ref];
                if (way === void 0) {
                  if (options.verbose) console.warn("Multipolygon", mp_geometry2 + "/" + mp_id, "tainted by a missing way", m.type + "/" + m.ref);
                  is_tainted = true;
                  return;
                }
                return {
                  // TODO: this is slow! :(
                  id: m.ref,
                  role: m.role || "outer",
                  way,
                  nodes: way.nodes.filter(function(n) {
                    if (n !== void 0)
                      return true;
                    is_tainted = true;
                    if (options.verbose) console.warn("Multipolygon", mp_geometry2 + "/" + mp_id, "tainted by a way", m.type + "/" + m.ref, "with a missing node");
                    return false;
                  })
                };
              });
              members = _.compact(members);
              var outers, inners;
              function join(ways2) {
                var _first = function(arr) {
                  return arr[0];
                };
                var _last = function(arr) {
                  return arr[arr.length - 1];
                };
                var joined = [], current, first, last, i2, how, what;
                while (ways2.length) {
                  current = ways2.pop().nodes.slice();
                  joined.push(current);
                  while (ways2.length && _first(current) !== _last(current)) {
                    first = _first(current);
                    last = _last(current);
                    for (i2 = 0; i2 < ways2.length; i2++) {
                      what = ways2[i2].nodes;
                      if (last === _first(what)) {
                        how = current.push;
                        what = what.slice(1);
                        break;
                      } else if (last === _last(what)) {
                        how = current.push;
                        what = what.slice(0, -1).reverse();
                        break;
                      } else if (first == _last(what)) {
                        how = current.unshift;
                        what = what.slice(0, -1);
                        break;
                      } else if (first == _first(what)) {
                        how = current.unshift;
                        what = what.slice(1).reverse();
                        break;
                      } else {
                        what = how = null;
                      }
                    }
                    if (!what) {
                      if (options.verbose) console.warn("Multipolygon", mp_geometry2 + "/" + mp_id, "contains unclosed ring geometry");
                      break;
                    }
                    ways2.splice(i2, 1);
                    how.apply(current, what);
                  }
                }
                return joined;
              }
              outers = join(members.filter(function(m) {
                return m.role === "outer";
              }));
              inners = join(members.filter(function(m) {
                return m.role === "inner";
              }));
              var mp;
              function findOuter(inner) {
                var polygonIntersectsPolygon = function(outer2, inner2) {
                  for (var i2 = 0; i2 < inner2.length; i2++)
                    if (pointInPolygon(inner2[i2], outer2))
                      return true;
                  return false;
                };
                var mapCoordinates = function(from) {
                  return from.map(function(n) {
                    return [+n.lat, +n.lon];
                  });
                };
                var pointInPolygon = function(point, polygon) {
                  var x = point[0], y = point[1], inside = false;
                  for (var i2 = 0, j3 = polygon.length - 1; i2 < polygon.length; j3 = i2++) {
                    var xi = polygon[i2][0], yi = polygon[i2][1];
                    var xj = polygon[j3][0], yj = polygon[j3][1];
                    var intersect = yi > y != yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
                    if (intersect) inside = !inside;
                  }
                  return inside;
                };
                var o2, outer;
                inner = mapCoordinates(inner);
                for (o2 = 0; o2 < outers.length; o2++) {
                  outer = mapCoordinates(outers[o2]);
                  if (polygonIntersectsPolygon(outer, inner))
                    return o2;
                }
              }
              mp = outers.map(function(o2) {
                return [o2];
              });
              for (var j2 = 0; j2 < inners.length; j2++) {
                var o = findOuter(inners[j2]);
                if (o !== void 0)
                  mp[o].push(inners[j2]);
                else if (options.verbose) console.warn("Multipolygon", mp_geometry2 + "/" + mp_id, "contains an inner ring with no containing outer");
                ;
              }
              var mp_coords = [];
              mp_coords = _.compact(mp.map(function(cluster) {
                var cl = _.compact(cluster.map(function(ring) {
                  if (ring.length < 4) {
                    if (options.verbose) console.warn("Multipolygon", mp_geometry2 + "/" + mp_id, "contains a ring with less than four nodes");
                    return;
                  }
                  return _.compact(ring.map(function(node) {
                    return [+node.lon, +node.lat];
                  }));
                }));
                if (cl.length == 0) {
                  if (options.verbose) console.warn("Multipolygon", mp_geometry2 + "/" + mp_id, "contains an empty ring cluster");
                  return;
                }
                return cl;
              }));
              if (mp_coords.length == 0) {
                if (options.verbose) console.warn("Multipolygon", mp_geometry2 + "/" + mp_id, "contains no coordinates");
                return false;
              }
              var mp_type = "MultiPolygon";
              if (mp_coords.length === 1) {
                mp_type = "Polygon";
                mp_coords = mp_coords[0];
              }
              var feature2 = {
                "type": "Feature",
                "id": tag_object.type + "/" + mp_id,
                "properties": {
                  "type": tag_object.type,
                  "id": mp_id,
                  "tags": tag_object.tags || {},
                  "relations": relsmap[tag_object.type][tag_object.id] || [],
                  "meta": build_meta_information(tag_object)
                },
                "geometry": {
                  "type": mp_type,
                  "coordinates": mp_coords
                }
              };
              if (is_tainted) {
                if (options.verbose) console.warn("Multipolygon", mp_geometry2 + "/" + mp_id, "is tainted");
                feature2.properties["tainted"] = true;
              }
              return feature2;
            };
            var construct_multipolygon = construct_multipolygon2;
            if (!_.isArray(rels[i].members)) {
              if (options.verbose) console.warn("Multipolygon", rels[i].type + "/" + rels[i].id, "ignored because it has no members");
              continue;
            }
            var outer_count = 0;
            for (var j = 0; j < rels[i].members.length; j++)
              if (rels[i].members[j].role == "outer")
                outer_count++;
              else if (options.verbose && rels[i].members[j].role != "inner")
                console.warn("Multipolygon", rels[i].type + "/" + rels[i].id, "member", rels[i].members[j].type + "/" + rels[i].members[j].ref, 'ignored because it has an invalid role: "' + rels[i].members[j].role + '"');
            rels[i].members.forEach(function(m) {
              if (wayids[m.ref]) {
                if (m.role === "outer" && !has_interesting_tags(wayids[m.ref].tags, rels[i].tags))
                  wayids[m.ref].is_multipolygon_outline = true;
                if (m.role === "inner" && !has_interesting_tags(wayids[m.ref].tags))
                  wayids[m.ref].is_multipolygon_outline = true;
              }
            });
            if (outer_count == 0) {
              if (options.verbose) console.warn("Multipolygon relation", rels[i].type + "/" + rels[i].id, "ignored because it has no outer ways");
              continue;
            }
            var simple_mp = false;
            var mp_geometry = "";
            if (outer_count == 1 && !has_interesting_tags(rels[i].tags, { "type": true }))
              simple_mp = true;
            var feature = null;
            if (!simple_mp) {
              feature = construct_multipolygon2(rels[i], rels[i]);
            } else {
              var outer_way = rels[i].members.filter(function(m) {
                return m.role === "outer";
              })[0];
              outer_way = wayids[outer_way.ref];
              if (outer_way === void 0) {
                if (options.verbose) console.warn("Multipolygon relation", rels[i].type + "/" + rels[i].id, "ignored because outer way", outer_way.type + "/" + outer_way.ref, "is missing");
                continue;
              }
              outer_way.is_multipolygon_outline = true;
              feature = construct_multipolygon2(outer_way, rels[i]);
            }
            if (feature === false) {
              if (options.verbose) console.warn("Multipolygon relation", rels[i].type + "/" + rels[i].id, "ignored because it has invalid geometry");
              continue;
            }
            geojsonpolygons.features.push(feature);
          }
        }
        for (var i = 0; i < ways.length; i++) {
          if (!_.isArray(ways[i].nodes)) {
            if (options.verbose) console.warn("Way", ways[i].type + "/" + ways[i].id, "ignored because it has no nodes");
            continue;
          }
          if (ways[i].is_multipolygon_outline)
            continue;
          if (typeof ways[i].id !== "number") {
            ways[i].id = +ways[i].id.replace("_fullGeom", "");
          }
          ways[i].tainted = false;
          ways[i].hidden = false;
          var coords = new Array();
          for (j = 0; j < ways[i].nodes.length; j++) {
            if (typeof ways[i].nodes[j] == "object")
              coords.push([+ways[i].nodes[j].lon, +ways[i].nodes[j].lat]);
            else {
              if (options.verbose) console.warn("Way", ways[i].type + "/" + ways[i].id, "is tainted by an invalid node");
              ways[i].tainted = true;
            }
          }
          if (coords.length <= 1) {
            if (options.verbose) console.warn("Way", ways[i].type + "/" + ways[i].id, "ignored because it contains too few nodes");
            continue;
          }
          var way_type = "LineString";
          if (typeof ways[i].nodes[0] != "undefined" && // way has its nodes loaded
          ways[i].nodes[0] === ways[i].nodes[ways[i].nodes.length - 1] && // ... and forms a closed ring
          (typeof ways[i].tags != "undefined" && // ... and has tags
          _isPolygonFeature(ways[i].tags) || // or is a placeholder for a bounds geometry
          ways[i].__is_bounds_placeholder)) {
            way_type = "Polygon";
            coords = [coords];
          }
          var feature = {
            "type": "Feature",
            "id": ways[i].type + "/" + ways[i].id,
            "properties": {
              "type": ways[i].type,
              "id": ways[i].id,
              "tags": ways[i].tags || {},
              "relations": relsmap["way"][ways[i].id] || [],
              "meta": build_meta_information(ways[i])
            },
            "geometry": {
              "type": way_type,
              "coordinates": coords
            }
          };
          if (ways[i].tainted) {
            if (options.verbose) console.warn("Way", ways[i].type + "/" + ways[i].id, "is tainted");
            feature.properties["tainted"] = true;
          }
          if (ways[i].__is_bounds_placeholder)
            feature.properties["geometry"] = "bounds";
          if (way_type == "LineString")
            geojsonlines.features.push(feature);
          else
            geojsonpolygons.features.push(feature);
        }
        geojson = {
          "type": "FeatureCollection",
          "features": []
        };
        geojson.features = geojson.features.concat(geojsonpolygons.features);
        geojson.features = geojson.features.concat(geojsonlines.features);
        geojson.features = geojson.features.concat(geojsonnodes.features);
        if (options.flatProperties) {
          geojson.features.forEach(function(f) {
            f.properties = _.merge(
              f.properties.meta,
              f.properties.tags,
              { id: f.properties.type + "/" + f.properties.id }
            );
          });
        }
        geojson = rewind(
          geojson,
          true
          /*remove for geojson-rewind >0.1.0*/
        );
        return geojson;
      }
      function _isPolygonFeature(tags) {
        var polygonFeatures2 = options.polygonFeatures;
        if (typeof polygonFeatures2 === "function")
          return polygonFeatures2(tags);
        if (tags["area"] === "no")
          return false;
        for (var key in tags) {
          var val = tags[key];
          var pfk = polygonFeatures2[key];
          if (typeof pfk === "undefined")
            continue;
          if (val === "no")
            continue;
          if (pfk === true)
            return true;
          if (pfk.included_values && pfk.included_values[val] === true)
            return true;
          if (pfk.excluded_values && pfk.excluded_values[val] !== true)
            return true;
        }
        return false;
      }
    };
    osmtogeojson.toGeojson = osmtogeojson;
    module.exports = osmtogeojson;
  }
});
export default require_osmtogeojson();
/*! Bundled license information:

osmtogeojson/lodash.custom.js:
  (**
   * @license
   * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
   * Build: `lodash exports="node" include="clone,merge,isEmpty,isArray,compact,each" -d`
   * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
   * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
   * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   * Available under MIT license <http://lodash.com/license>
   *)
*/
//# sourceMappingURL=osmtogeojson.js.map
